<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app.js" />
              <option name="originalContent" value="const express = require('express');&#10;const cors = require('cors');&#10;const helmet = require('helmet');&#10;const cookieParser = require('cookie-parser');&#10;const session = require('express-session');&#10;const passport = require('passport');&#10;require('dotenv').config();&#10;&#10;const authRoutes = require('./routes/authRoutes'); // fixed path&#10;const userRoutes = require('./routes/userRoutes');&#10;&#10;const app = express();&#10;app.use(helmet());&#10;app.use(cors({&#10;  origin: process.env.CLIENT_URL || '*',&#10;  credentials: true&#10;}));&#10;app.use(express.json());&#10;app.use(cookieParser());&#10;app.use(express.urlencoded({ extended: true }));&#10;&#10;// Disable session persistence in test environment to simplify&#10;if (process.env.NODE_ENV !== 'test') {&#10;  app.use(session({&#10;    secret: process.env.SESSION_SECRET || 'session-secret',&#10;    resave: false,&#10;    saveUninitialized: true,&#10;    cookie: {&#10;      secure: process.env.NODE_ENV === 'production',&#10;      maxAge: 24 * 60 * 60 * 1000,&#10;      httpOnly: true&#10;    }&#10;  }));&#10;  app.use(passport.initialize());&#10;  app.use(passport.session());&#10;} else {&#10;  app.use(passport.initialize());&#10;}&#10;&#10;app.use('/api/auth', authRoutes);&#10;app.use('/api/users', userRoutes);&#10;&#10;app.use((err, req, res, next) =&gt; {&#10;  console.error(err.stack);&#10;  res.status(500).json({ success: false, error: 'Something went wrong!' });&#10;});&#10;&#10;module.exports = app;" />
              <option name="updatedContent" value="const express = require('express');&#10;const cors = require('cors');&#10;const helmet = require('helmet');&#10;const cookieParser = require('cookie-parser');&#10;const session = require('express-session');&#10;const passport = require('passport');&#10;const env = require('./config/env');&#10;&#10;const authRoutes = require('./routes/authRoutes');&#10;const userRoutes = require('./routes/userRoutes');&#10;&#10;const app = express();&#10;app.use(helmet());&#10;app.use(cors({&#10;  origin: env.CLIENT_URL || '*',&#10;  credentials: true&#10;}));&#10;app.use(express.json());&#10;app.use(cookieParser());&#10;app.use(express.urlencoded({ extended: true }));&#10;&#10;if (env.NODE_ENV !== 'test') {&#10;  app.use(session({&#10;    secret: env.SESSION_SECRET || 'session-secret',&#10;    resave: false,&#10;    saveUninitialized: true,&#10;    cookie: {&#10;      secure: env.NODE_ENV === 'production',&#10;      maxAge: 24 * 60 * 60 * 1000,&#10;      httpOnly: true&#10;    }&#10;  }));&#10;  app.use(passport.initialize());&#10;  app.use(passport.session());&#10;} else {&#10;  app.use(passport.initialize());&#10;}&#10;&#10;app.use('/api/auth', authRoutes);&#10;app.use('/api/users', userRoutes);&#10;&#10;app.use((err, req, res, next) =&gt; {&#10;  console.error(err.stack);&#10;  res.status(500).json({ success: false, error: 'Something went wrong!' });&#10;});&#10;&#10;module.exports = app;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/database.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/database.js" />
              <option name="originalContent" value="const { Sequelize } = require('sequelize');&#10;require('dotenv').config();&#10;&#10;let sequelize;&#10;if (process.env.NODE_ENV === 'test') {&#10;  sequelize = new Sequelize('sqlite::memory:', {&#10;    dialect: 'sqlite',&#10;    logging: false&#10;  });&#10;} else {&#10;  sequelize = new Sequelize(&#10;    process.env.DATABASE_NAME,&#10;    process.env.DATABASE_USER,&#10;    process.env.DATABASE_PASSWORD,&#10;    {&#10;      host: process.env.DATABASE_HOST,&#10;      port: process.env.DATABASE_PORT || 5432,&#10;      dialect: 'postgres',&#10;      pool: {&#10;        max: 10,&#10;        min: 0,&#10;        acquire: 30000,&#10;        idle: 10000&#10;      },&#10;      logging: false&#10;    }&#10;  );&#10;}&#10;&#10;const testConnection = async () =&gt; {&#10;  try {&#10;    await sequelize.authenticate();&#10;    console.log('Connection has been established successfully.');&#10;  } catch (e) {&#10;    console.error('Unable to connect to the database:', e.message);&#10;  }&#10;};&#10;&#10;module.exports = { sequelize, testConnection };&#10;" />
              <option name="updatedContent" value="const { Sequelize } = require('sequelize');&#10;// Replace direct dotenv usage with centralized env loader&#10;const env = require('./env');&#10;&#10;function resolvePassword() {&#10;  // file secret precedence&#10;  if (env.DATABASE_PASSWORD_FILE) {&#10;    try {&#10;      const fs = require('fs');&#10;      const pwd = fs.readFileSync(env.DATABASE_PASSWORD_FILE, 'utf8').trim();&#10;      return String(pwd);&#10;    } catch (e) {&#10;      console.warn('DATABASE_PASSWORD_FILE read failed:', e.message);&#10;    }&#10;  }&#10;  const raw = env.DATABASE_PASSWORD;&#10;  if (raw == null) return '';&#10;  return typeof raw === 'string' ? raw : String(raw);&#10;}&#10;&#10;let sequelize;&#10;if (env.NODE_ENV === 'test') {&#10;  sequelize = new Sequelize('sqlite::memory:', {&#10;    dialect: 'sqlite',&#10;    logging: false&#10;  });&#10;} else {&#10;  const password = resolvePassword();&#10;  if (!password) {&#10;    console.warn('Warning: DATABASE_PASSWORD is empty.');&#10;  }&#10;  if (env.DB_DEBUG === '1') {&#10;    console.log('[DB_DEBUG] Initializing Sequelize with params', {&#10;      database: env.DATABASE_NAME,&#10;      user: env.DATABASE_USER,&#10;      host: env.DATABASE_HOST || 'localhost',&#10;      port: env.DATABASE_PORT || 5432,&#10;      passwordType: typeof password,&#10;      passwordLength: password.length&#10;    });&#10;  }&#10;  sequelize = new Sequelize(&#10;    env.DATABASE_NAME,&#10;    env.DATABASE_USER,&#10;    password,&#10;    {&#10;      host: env.DATABASE_HOST || 'localhost',&#10;      port: env.DATABASE_PORT || 5432,&#10;      dialect: 'postgres',&#10;      pool: {&#10;        max: 10,&#10;        min: 0,&#10;        acquire: 30000,&#10;        idle: 10000&#10;      },&#10;      logging: env.DB_SQL_LOG === '1' ? console.log : false&#10;    }&#10;  );&#10;}&#10;&#10;const testConnection = async () =&gt; {&#10;  try {&#10;    if (env.DB_DEBUG === '1') console.log('[DB_DEBUG] Authenticating...');&#10;    await sequelize.authenticate();&#10;    console.log('Connection has been established successfully.');&#10;  } catch (e) {&#10;    console.error('[DB_CONNECT_ERROR] Unable to connect to the database:', e.message);&#10;    throw e; // rethrow so caller can handle&#10;  }&#10;};&#10;&#10;module.exports = { sequelize, testConnection };" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/env.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/env.js" />
              <option name="updatedContent" value="// Centralized environment loader&#10;// Loads test env (.env.test) if present in test mode, otherwise loads local 'env' file.&#10;// Falls back to default dotenv behavior if custom file missing.&#10;const fs = require('fs');&#10;const path = require('path');&#10;const dotenv = require('dotenv');&#10;&#10;function load() {&#10;  if (process.env.__ENV_LOADED) return; // idempotent&#10;  const cwd = process.cwd();&#10;  const isTest = process.env.NODE_ENV === 'test';&#10;  const testFile = path.join(cwd, '.env.test');&#10;  const localFile = path.join(cwd, 'env');&#10;  let chosen;&#10;  if (isTest &amp;&amp; fs.existsSync(testFile)) {&#10;    chosen = testFile;&#10;  } else if (fs.existsSync(localFile)) {&#10;    chosen = localFile;&#10;  }&#10;  if (chosen) {&#10;    dotenv.config({ path: chosen });&#10;  } else {&#10;    dotenv.config(); // fallback to default .env&#10;  }&#10;  process.env.__ENV_LOADED = '1';&#10;}&#10;&#10;load();&#10;&#10;module.exports = process.env;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/passport.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/passport.js" />
              <option name="originalContent" value="const passport = require('passport');&#10;const GoogleStrategy = require('passport-google-oauth20').Strategy;&#10;const { Strategy: JwtStrategy, ExtractJwt } = require('passport-jwt');&#10;const User  = require('../models/User');&#10;require('dotenv').config();&#10;&#10;&#10;passport.use(new GoogleStrategy({&#10;  clientID: process.env.GOOGLE_CLIENT_ID || 'dummy-id',&#10;  clientSecret: process.env.GOOGLE_CLIENT_SECRET || 'dummy-secret',&#10;  callbackURL: process.env.GOOGLE_CALLBACK_URL || 'http://localhost:5000/api/auth/google/callback',&#10;  passReqToCallback: true&#10;}, async (request, accessToken, refreshToken, profile, done) =&gt; {&#10;  try {&#10;    const email = profile.emails?.[0]?.value;&#10;    const googleId = profile.id;&#10;    const firstName = profile.name?.givenName;&#10;    const lastName = profile.name?.familyName;&#10;    const profilePicture = profile.photos?.[0]?.value;&#10;&#10;    let user = await User.findOne({ where: { googleId } });&#10;    if (user) {&#10;      user.lastLogin = new Date();&#10;      await user.save();&#10;      return done(null, user);&#10;    }&#10;    user = await User.findOne({ where: { email } });&#10;    if (user &amp;&amp; user.authProvider === 'local') {&#10;      user.googleId = googleId;&#10;      user.authProvider = 'google';&#10;      user.isEmailVerified = true;&#10;      user.profilePicture = profilePicture;&#10;      user.lastLogin = new Date();&#10;      await user.save();&#10;      return done(null, user);&#10;    }&#10;    const userType = request.session?.userType || 'freelancer';&#10;    const newUser = await User.create({&#10;      email,&#10;      googleId,&#10;      authProvider: 'google',&#10;      firstName,&#10;      lastName,&#10;      profilePicture,&#10;      isEmailVerified: true,&#10;      userType,&#10;      lastLogin: new Date()&#10;    });&#10;    return done(null, newUser);&#10;  } catch (e) {&#10;    return done(e, null);&#10;  }&#10;}));&#10;&#10;const jwtSecret = process.env.JWT_ACCESS_SECRET || process.env.JWT_SECRET;&#10;if (jwtSecret) {&#10;  const jwtOptions = {&#10;    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),&#10;    secretOrKey: jwtSecret&#10;  };&#10;  passport.use(new JwtStrategy(jwtOptions, async (jwtPayload, done) =&gt; {&#10;    try {&#10;      const user = await User.findByPk(jwtPayload.id);&#10;      if (!user || !user.isActive) {&#10;        return done(null, false);&#10;      }&#10;      return done(null, user);&#10;    } catch (e) {&#10;      return done(e, false);&#10;    }&#10;  }));&#10;}&#10;&#10;module.exports = passport;" />
              <option name="updatedContent" value="const passport = require('passport');&#10;const GoogleStrategy = require('passport-google-oauth20').Strategy;&#10;const { Strategy: JwtStrategy, ExtractJwt } = require('passport-jwt');&#10;const User  = require('../models/User');&#10;const env = require('./env');&#10;&#10;&#10;passport.use(new GoogleStrategy({&#10;  clientID: env.GOOGLE_CLIENT_ID || 'dummy-id',&#10;  clientSecret: env.GOOGLE_CLIENT_SECRET || 'dummy-secret',&#10;  callbackURL: env.GOOGLE_CALLBACK_URL || 'http://localhost:5000/api/auth/google/callback',&#10;  passReqToCallback: true&#10;}, async (request, accessToken, refreshToken, profile, done) =&gt; {&#10;  try {&#10;    const email = profile.emails?.[0]?.value;&#10;    const googleId = profile.id;&#10;    const firstName = profile.name?.givenName;&#10;    const lastName = profile.name?.familyName;&#10;    const profilePicture = profile.photos?.[0]?.value;&#10;&#10;    let user = await User.findOne({ where: { googleId } });&#10;    if (user) {&#10;      user.lastLogin = new Date();&#10;      await user.save();&#10;      return done(null, user);&#10;    }&#10;    user = await User.findOne({ where: { email } });&#10;    if (user &amp;&amp; user.authProvider === 'local') {&#10;      user.googleId = googleId;&#10;      user.authProvider = 'google';&#10;      user.isEmailVerified = true;&#10;      user.profilePicture = profilePicture;&#10;      user.lastLogin = new Date();&#10;      await user.save();&#10;      return done(null, user);&#10;    }&#10;    const userType = request.session?.userType || 'freelancer';&#10;    const newUser = await User.create({&#10;      email,&#10;      googleId,&#10;      authProvider: 'google',&#10;      firstName,&#10;      lastName,&#10;      profilePicture,&#10;      isEmailVerified: true,&#10;      userType,&#10;      lastLogin: new Date()&#10;    });&#10;    return done(null, newUser);&#10;  } catch (e) {&#10;    return done(e, null);&#10;  }&#10;}));&#10;&#10;const jwtSecret = env.JWT_ACCESS_SECRET || env.JWT_SECRET;&#10;if (jwtSecret) {&#10;  const jwtOptions = {&#10;    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),&#10;    secretOrKey: jwtSecret&#10;  };&#10;  passport.use(new JwtStrategy(jwtOptions, async (jwtPayload, done) =&gt; {&#10;    try {&#10;      const user = await User.findByPk(jwtPayload.id);&#10;      if (!user || !user.isActive) {&#10;        return done(null, false);&#10;      }&#10;      return done(null, user);&#10;    } catch (e) {&#10;      return done(e, false);&#10;    }&#10;  }));&#10;}&#10;&#10;module.exports = passport;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/database/migration.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/database/migration.js" />
              <option name="originalContent" value="const {sequelize} = require('../config/database');&#10;require('dotenv').config();&#10;&#10;&#10;const runMigrations = async () =&gt; {&#10;  try {&#10;    await sequelize.authenticate();&#10;    console.log('Database connection established successfully.');&#10;&#10;    // Run migrations&#10;    await sequelize.sync({force: process.env.FORCE_SYNC === 'true'});&#10;    console.log('Running migrations...');&#10;&#10;    // Here you would typically use a migration tool like Sequelize CLI or Umzug&#10;    // For demonstration, we will just log that migrations are run&#10;    console.log('Migrations completed successfully.');&#10;&#10;    process.exit(0)&#10;  } catch (error) {&#10;    console.error('Error running migrations:', error.message);&#10;    process.exit(1)&#10;  } finally {&#10;    await sequelize.close();&#10;  }&#10;}&#10;&#10;&#10;&#10;runMigrations()" />
              <option name="updatedContent" value="const {sequelize} = require('../config/database');&#10;const env = require('../config/env');&#10;&#10;const runMigrations = async () =&gt; {&#10;  try {&#10;    await sequelize.authenticate();&#10;    console.log('Database connection established successfully.');&#10;    await sequelize.sync({force: env.FORCE_SYNC === 'true'});&#10;    console.log('Running migrations...');&#10;    console.log('Migrations completed successfully.');&#10;    process.exit(0)&#10;  } catch (error) {&#10;    console.error('Error running migrations:', error.message);&#10;    process.exit(1)&#10;  } finally {&#10;    await sequelize.close();&#10;  }&#10;}&#10;&#10;runMigrations()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/models/User.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/models/User.js" />
              <option name="originalContent" value="const { DataTypes } = require('sequelize');&#10;const { sequelize } = require('../config/database');&#10;const bcrypt = require('bcryptjs');&#10;&#10;&#10;const User = sequelize.define('User', {&#10;  id: {&#10;    type: DataTypes.UUID,&#10;    defaultValue: DataTypes.UUIDV4,&#10;    primaryKey: true&#10;  },&#10;  email: {&#10;    type: DataTypes.STRING,&#10;    allowNull: false,&#10;    unique: true,&#10;    validate: {&#10;      isEmail: true&#10;    }&#10;  },&#10;  passwordHash: {&#10;    type: DataTypes.STRING,&#10;    allowNull: false,&#10;    field: 'password_hash'&#10;  },&#10;  authProvider: {&#10;    type: DataTypes.ENUM('local', 'google'),&#10;    allowNull: false,&#10;    defaultValue: 'local',&#10;    field: 'auth_provider'&#10;  },&#10;  googleId: {&#10;    type: DataTypes.STRING,&#10;    unique: true,&#10;    allowNull: true,&#10;    field: 'google_id'&#10;  },&#10;  userType: {&#10;    type: DataTypes.STRING,&#10;    allowNull: false,&#10;    field: 'user_type'&#10;  },&#10;  firstName: {&#10;    type: DataTypes.STRING,&#10;    field: 'first_name',&#10;    allowNull: false&#10;  },&#10;  lastName: {&#10;    type: DataTypes.STRING,&#10;    field: 'last_name',&#10;    allowNull: false&#10;  },&#10;  profilePicture: {&#10;    type: DataTypes.STRING,&#10;    field: 'profile_picture',&#10;    allowNull: true&#10;  },&#10;  isEmailVerified: {&#10;    type: DataTypes.BOOLEAN,&#10;    defaultValue: false,&#10;    field: 'is_email_verified'&#10;  },&#10;  emailVerificationToken: {&#10;    type: DataTypes.STRING,&#10;    field: 'email_verification_token',&#10;    allowNull: true&#10;  },&#10;  passwordResetToken: {&#10;    type: DataTypes.STRING,&#10;    field: 'password_reset_token',&#10;    allowNull: true&#10;  },&#10;  passwordResetExpires: {&#10;    type: DataTypes.DATE,&#10;    field: 'password_reset_expires',&#10;    allowNull: true&#10;  },&#10;  refreshToken: {&#10;    type: DataTypes.STRING,&#10;    field: 'refresh_token',&#10;    allowNull: true&#10;  },&#10;  lastLogin: {&#10;    type: DataTypes.DATE,&#10;    field: 'last_login',&#10;    allowNull: true&#10;  },&#10;  isActive: {&#10;    type: DataTypes.BOOLEAN,&#10;    defaultValue: true,&#10;    field: 'is_active'&#10;  }&#10;}, {&#10;  tableName: 'users',&#10;  timestamps: true,&#10;  underscored: true,&#10;  indexes: [&#10;    { unique: true, fields: ['email'] },&#10;    { unique: true, fields: ['google_id'], where: { google_id: { [sequelize.Sequelize?.Op?.ne]: null } } },&#10;    { fields: ['user_type'] },&#10;    { fields: ['auth_provider'] }&#10;  ]&#10;});&#10;&#10;User.hashPassword = async function (password) {&#10;  const salt = await bcrypt.genSalt(10);&#10;  return bcrypt.hash(password, salt);&#10;};&#10;&#10;User.prototype.validatePassword = async function (password) {&#10;  return bcrypt.compare(password, this.passwordHash);&#10;};&#10;&#10;User.prototype.getPublicProfile = function () {&#10;  return {&#10;    id: this.id,&#10;    email: this.email,&#10;    userType: this.userType,&#10;    firstName: this.firstName,&#10;    lastName: this.lastName,&#10;    profilePicture: this.profilePicture,&#10;    isEmailVerified: this.isEmailVerified,&#10;    authProvider: this.authProvider,&#10;    isActive: this.isActive,&#10;    lastLogin: this.lastLogin,&#10;    createdAt: this.createdAt,&#10;    updatedAt: this.updatedAt&#10;  };&#10;};&#10;&#10;module.exports = User;&#10;" />
              <option name="updatedContent" value="const { DataTypes } = require('sequelize');&#10;const { sequelize } = require('../config/database');&#10;const bcrypt = require('bcryptjs');&#10;&#10;&#10;const User = sequelize.define('User', {&#10;  id: {&#10;    type: DataTypes.UUID,&#10;    defaultValue: DataTypes.UUIDV4,&#10;    primaryKey: true&#10;  },&#10;  email: {&#10;    type: DataTypes.STRING,&#10;    allowNull: false,&#10;    unique: true,&#10;    validate: {&#10;      isEmail: true&#10;    }&#10;  },&#10;  passwordHash: {&#10;    type: DataTypes.STRING,&#10;    allowNull: false,&#10;    field: 'password_hash'&#10;  },&#10;  authProvider: {&#10;    type: DataTypes.ENUM('local', 'google'),&#10;    allowNull: false,&#10;    defaultValue: 'local',&#10;    field: 'auth_provider'&#10;  },&#10;  googleId: {&#10;    type: DataTypes.STRING,&#10;    unique: true,&#10;    allowNull: true,&#10;    field: 'google_id'&#10;  },&#10;  userType: {&#10;    type: DataTypes.STRING,&#10;    allowNull: false,&#10;    field: 'user_type'&#10;  },&#10;  firstName: {&#10;    type: DataTypes.STRING,&#10;    field: 'first_name',&#10;    allowNull: false&#10;  },&#10;  lastName: {&#10;    type: DataTypes.STRING,&#10;    field: 'last_name',&#10;    allowNull: false&#10;  },&#10;  profilePicture: {&#10;    type: DataTypes.STRING,&#10;    field: 'profile_picture',&#10;    allowNull: true&#10;  },&#10;  isEmailVerified: {&#10;    type: DataTypes.BOOLEAN,&#10;    defaultValue: false,&#10;    field: 'is_email_verified'&#10;  },&#10;  emailVerificationToken: {&#10;    type: DataTypes.TEXT, // was STRING&#10;    field: 'email_verification_token',&#10;    allowNull: true&#10;  },&#10;  passwordResetToken: {&#10;    type: DataTypes.TEXT, // was STRING&#10;    field: 'password_reset_token',&#10;    allowNull: true&#10;  },&#10;  passwordResetExpires: {&#10;    type: DataTypes.DATE,&#10;    field: 'password_reset_expires',&#10;    allowNull: true&#10;  },&#10;  refreshToken: {&#10;    type: DataTypes.TEXT, // was STRING&#10;    field: 'refresh_token',&#10;    allowNull: true&#10;  },&#10;  lastLogin: {&#10;    type: DataTypes.DATE,&#10;    field: 'last_login',&#10;    allowNull: true&#10;  },&#10;  isActive: {&#10;    type: DataTypes.BOOLEAN,&#10;    defaultValue: true,&#10;    field: 'is_active'&#10;  }&#10;}, {&#10;  tableName: 'users',&#10;  timestamps: true,&#10;  underscored: true,&#10;  indexes: [&#10;    { unique: true, fields: ['email'] },&#10;    { unique: true, fields: ['google_id'], where: { google_id: { [sequelize.Sequelize?.Op?.ne]: null } } },&#10;    { fields: ['user_type'] },&#10;    { fields: ['auth_provider'] }&#10;  ]&#10;});&#10;&#10;User.hashPassword = async function (password) {&#10;  const salt = await bcrypt.genSalt(10);&#10;  return bcrypt.hash(password, salt);&#10;};&#10;&#10;User.prototype.validatePassword = async function (password) {&#10;  return bcrypt.compare(password, this.passwordHash);&#10;};&#10;&#10;User.prototype.getPublicProfile = function () {&#10;  return {&#10;    id: this.id,&#10;    email: this.email,&#10;    userType: this.userType,&#10;    firstName: this.firstName,&#10;    lastName: this.lastName,&#10;    profilePicture: this.profilePicture,&#10;    isEmailVerified: this.isEmailVerified,&#10;    authProvider: this.authProvider,&#10;    isActive: this.isActive,&#10;    lastLogin: this.lastLogin,&#10;    createdAt: this.createdAt,&#10;    updatedAt: this.updatedAt&#10;  };&#10;};&#10;&#10;module.exports = User;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/server.js" />
              <option name="originalContent" value="const app = require('./app')&#10;const {sequelize, testConnection} = require('./config/database');&#10;require('dotenv').config();&#10;&#10;const PORT = process.env.PORT || 5000;&#10;&#10;const startServer = async () =&gt; {&#10;  try {&#10;    await testConnection();&#10;    await  sequelize.sync ({ alter: process.env.NODE_ENV === 'development' });&#10;    console.log('Database model synced successfully.');&#10;&#10;    app.listen(PORT, () =&gt; {&#10;      console.log(`Server is running on port ${PORT}`);&#10;    });&#10;  } catch (error) {&#10;    console.error('Unable to connect to the database:', error.message);&#10;    process.exit(1);&#10;  }&#10;}&#10;&#10;startServer()" />
              <option name="updatedContent" value="const app = require('./app')&#10;const {sequelize, testConnection} = require('./config/database');&#10;const env = require('./config/env');&#10;&#10;const PORT = env.PORT || 5000;&#10;&#10;const startServer = async () =&gt; {&#10;  try {&#10;    await testConnection();&#10;    await sequelize.sync({ alter: env.NODE_ENV === 'development' });&#10;    console.log('Database model synced successfully.');&#10;    const server = app.listen(PORT, () =&gt; {&#10;      console.log(`Server is running on port ${PORT}`);&#10;    });&#10;    server.on('error', (err) =&gt; {&#10;      if (err.code === 'EADDRINUSE') {&#10;        console.error(`Port ${PORT} already in use. Set PORT to a free port or free the existing process.`);&#10;        process.exit(1);&#10;      }&#10;    });&#10;    const shutdown = async () =&gt; {&#10;      console.log('Shutting down gracefully...');&#10;      try { await sequelize.close(); } catch (_) {}&#10;      server.close(() =&gt; process.exit(0));&#10;    };&#10;    process.on('SIGINT', shutdown);&#10;    process.on('SIGTERM', shutdown);&#10;  } catch (error) {&#10;    console.error('Unable to connect to the database:', error.message);&#10;    process.exit(1);&#10;  }&#10;}&#10;&#10;startServer()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/utils/emailService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/utils/emailService.js" />
              <option name="originalContent" value="const nodeMailer = require('nodemailer');&#10;require('dotenv').config();&#10;&#10;const transporter = nodeMailer.createTransport({&#10;    host: process.env.EMAIL_HOST,&#10;    port: process.env.EMAIL_PORT,&#10;    service: &quot;gmail&quot;,&#10;    secure: false,&#10;    auth: {&#10;        user: process.env.EMAIL_USER,&#10;        pass: process.env.EMAIL_PASSWORD&#10;     }&#10;   })&#10;&#10;const sendVerificationEmail = async (email, token) =&gt; {&#10;  const verificationLink = `${process.env.CLIENT_URL}/api/auth/verify-email?token=${token}`;&#10;  const mailOptions = {&#10;&#10;    from: process.env.EMAIL_FROM,&#10;    to: email,&#10;    subject: 'Email Verification',&#10;    html: `&lt;p&gt;Please verify your email by clicking the link below:&lt;/p&gt;&#10;           &lt;a href=&quot;${verificationLink}&quot;&gt;Verify Email&lt;/a&gt;`&#10;  };&#10;&#10;  try {&#10;    console.log('Mail options:', mailOptions);&#10;    await transporter.sendMail(mailOptions)&#10;    console.log((`Verification email sent to ${email}`));&#10;    return true&#10;  }catch (e) {&#10;    console.error('Error sending verification email:', e);&#10;    return false&#10;  }&#10;&#10;}&#10;const sendPasswordResetEmail = async (to, token) =&gt; {&#10;  const resetLink = `${process.env.CLIENT_URL}/reset-password?token=${token}`;&#10;  const mailOptions = {&#10;    from: process.env.EMAIL_FROM,&#10;    to,&#10;    subject: 'Password Reset Request',&#10;    html: `&lt;p&gt;You requested a password reset. Click the link below to reset your password:&lt;/p&gt;&#10;           &lt;a href=&quot;${resetLink}&quot;&gt;Reset Password&lt;/a&gt;`&#10;  };&#10;&#10;  try {&#10;    await transporter.sendMail(mailOptions)&#10;    console.log((`Password reset email sent to ${to}`));&#10;    return true&#10;  }catch (e) {&#10;    console.error('Error sending password reset email:', e);&#10;    return false&#10;  }&#10;}&#10;&#10;&#10;module.exports = {&#10;    sendVerificationEmail,&#10;    sendPasswordResetEmail&#10;}" />
              <option name="updatedContent" value="const nodeMailer = require('nodemailer');&#10;const env = require('../config/env');&#10;&#10;const transporter = nodeMailer.createTransport({&#10;    host: env.EMAIL_HOST,&#10;    port: env.EMAIL_PORT,&#10;    service: &quot;gmail&quot;,&#10;    secure: false,&#10;    auth: {&#10;        user: env.EMAIL_USER,&#10;        pass: env.EMAIL_PASSWORD&#10;     }&#10;   })&#10;&#10;const sendVerificationEmail = async (email, token) =&gt; {&#10;  const verificationLink = `${env.CLIENT_URL}/api/auth/verify-email?token=${token}`;&#10;  const mailOptions = {&#10;    from: env.EMAIL_FROM,&#10;    to: email,&#10;    subject: 'Email Verification',&#10;    html: `&lt;p&gt;Please verify your email by clicking the link below:&lt;/p&gt;&#10;           &lt;a href=&quot;${verificationLink}&quot;&gt;Verify Email&lt;/a&gt;`&#10;  };&#10;&#10;  try {&#10;    console.log('Mail options:', mailOptions);&#10;    await transporter.sendMail(mailOptions)&#10;    console.log((`Verification email sent to ${email}`));&#10;    return true&#10;  }catch (e) {&#10;    console.error('Error sending verification email:', e);&#10;    return false&#10;  }&#10;}&#10;const sendPasswordResetEmail = async (to, token) =&gt; {&#10;  const resetLink = `${env.CLIENT_URL}/reset-password?token=${token}`;&#10;  const mailOptions = {&#10;    from: env.EMAIL_FROM,&#10;    to,&#10;    subject: 'Password Reset Request',&#10;    html: `&lt;p&gt;You requested a password reset. Click the link below to reset your password:&lt;/p&gt;&#10;           &lt;a href=&quot;${resetLink}&quot;&gt;Reset Password&lt;/a&gt;`&#10;  };&#10;&#10;  try {&#10;    await transporter.sendMail(mailOptions)&#10;    console.log((`Password reset email sent to ${to}`));&#10;    return true&#10;  }catch (e) {&#10;    console.error('Error sending password reset email:', e);&#10;    return false&#10;  }&#10;}&#10;&#10;module.exports = {&#10;    sendVerificationEmail,&#10;    sendPasswordResetEmail&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/utils/jwt.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/utils/jwt.js" />
              <option name="originalContent" value="const jwt = require('jsonwebtoken');&#10;require('dotenv').config();&#10;&#10;const getAccessSecret = () =&gt; process.env.JWT_ACCESS_SECRET || process.env.JWT_SECRET || 'access-secret';&#10;const getRefreshSecret = () =&gt; process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET || 'refresh-secret';&#10;const getAccessExpiry = () =&gt; process.env.JWT_ACCESS_EXPIRY || '15m';&#10;const getRefreshExpiry = () =&gt; process.env.JWT_REFRESH_EXPIRY || '7d';&#10;&#10;const generateAccessToken = (payload) =&gt; {&#10;  return jwt.sign(payload, getAccessSecret(), { expiresIn: getAccessExpiry() });&#10;};&#10;&#10;const generateRefreshToken = (payload) =&gt; {&#10;  return jwt.sign(payload, getRefreshSecret(), { expiresIn: getRefreshExpiry() });&#10;};&#10;&#10;const generateTokenPair = (payload) =&gt; ({&#10;  accessToken: generateAccessToken(payload),&#10;  refreshToken: generateRefreshToken(payload)&#10;});&#10;&#10;const verifyAccessToken = (token) =&gt; {&#10;  try {&#10;    return jwt.verify(token, getAccessSecret());&#10;  } catch (e) {&#10;    throw new Error('Invalid or expired access token');&#10;  }&#10;};&#10;&#10;const verifyRefreshToken = (token) =&gt; {&#10;  try {&#10;    return jwt.verify(token, getRefreshSecret());&#10;  } catch (e) {&#10;    throw new Error('Invalid or expired refresh token');&#10;  }&#10;};&#10;&#10;module.exports = {&#10;  generateAccessToken,&#10;  generateRefreshToken,&#10;  generateTokenPair,&#10;  verifyAccessToken,&#10;  verifyRefreshToken&#10;};" />
              <option name="updatedContent" value="const jwt = require('jsonwebtoken');&#10;const env = require('../config/env');&#10;&#10;const getAccessSecret = () =&gt; env.JWT_ACCESS_SECRET || env.JWT_SECRET || 'access-secret';&#10;const getRefreshSecret = () =&gt; env.JWT_REFRESH_SECRET || env.JWT_SECRET || 'refresh-secret';&#10;const getAccessExpiry = () =&gt; env.JWT_ACCESS_EXPIRY || '15m';&#10;const getRefreshExpiry = () =&gt; env.JWT_REFRESH_EXPIRY || '7d';&#10;&#10;const generateAccessToken = (payload) =&gt; {&#10;  return jwt.sign(payload, getAccessSecret(), { expiresIn: getAccessExpiry() });&#10;};&#10;&#10;const generateRefreshToken = (payload) =&gt; {&#10;  return jwt.sign(payload, getRefreshSecret(), { expiresIn: getRefreshExpiry() });&#10;};&#10;&#10;const generateTokenPair = (payload) =&gt; ({&#10;  accessToken: generateAccessToken(payload),&#10;  refreshToken: generateRefreshToken(payload)&#10;});&#10;&#10;const verifyAccessToken = (token) =&gt; {&#10;  try {&#10;    return jwt.verify(token, getAccessSecret());&#10;  } catch (e) {&#10;    throw new Error('Invalid or expired access token');&#10;  }&#10;};&#10;&#10;const verifyRefreshToken = (token) =&gt; {&#10;  try {&#10;    return jwt.verify(token, getRefreshSecret());&#10;  } catch (e) {&#10;    throw new Error('Invalid or expired refresh token');&#10;  }&#10;};&#10;&#10;module.exports = {&#10;  generateAccessToken,&#10;  generateRefreshToken,&#10;  generateTokenPair,&#10;  verifyAccessToken,&#10;  verifyRefreshToken&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/setup.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/setup.js" />
              <option name="originalContent" value="// Test setup file&#10;require('dotenv').config({ path: '.env.test' });&#10;&#10;// Set test environment&#10;process.env.NODE_ENV = 'test';&#10;process.env.JWT_ACCESS_SECRET = 'test-access-secret-key';&#10;process.env.JWT_REFRESH_SECRET = 'test-refresh-secret-key';&#10;process.env.JWT_ACCESS_EXPIRY = '15m';&#10;process.env.JWT_REFRESH_EXPIRY = '7d';&#10;&#10;// Mock console methods to reduce noise during tests&#10;global.console = {&#10;  ...console,&#10;  error: jest.fn(),&#10;  log: jest.fn(),&#10;  warn: jest.fn(),&#10;};&#10;&#10;// Mock nodemailer to avoid sending real emails&#10;jest.mock('nodemailer', () =&gt; ({&#10;  createTransport: () =&gt; ({&#10;    sendMail: jest.fn().mockResolvedValue(true),&#10;  }),&#10;}));&#10;&#10;// Ensure DB schema is ready for any non-mocked model usage&#10;const { sequelize } = require('../src/config/database');&#10;beforeAll(async () =&gt; {&#10;  try {&#10;    await sequelize.sync({ force: true });&#10;  } catch (e) {&#10;    console.error('DB sync error:', e.message);&#10;  }&#10;});&#10;&#10;afterAll(async () =&gt; {&#10;  try {&#10;    await sequelize.close();&#10;  } catch (e) {&#10;    // ignore&#10;  }&#10;});&#10;" />
              <option name="updatedContent" value="// Test setup file&#10;// require('dotenv').config({ path: '.env.test' });&#10;require('../src/config/env');&#10;&#10;// Set test environment&#10;process.env.NODE_ENV = 'test';&#10;process.env.JWT_ACCESS_SECRET = 'test-access-secret-key';&#10;process.env.JWT_REFRESH_SECRET = 'test-refresh-secret-key';&#10;process.env.JWT_ACCESS_EXPIRY = '15m';&#10;process.env.JWT_REFRESH_EXPIRY = '7d';&#10;&#10;// Mock console methods to reduce noise during tests&#10;global.console = {&#10;  ...console,&#10;  error: jest.fn(),&#10;  log: jest.fn(),&#10;  warn: jest.fn(),&#10;};&#10;&#10;// Mock nodemailer to avoid sending real emails&#10;jest.mock('nodemailer', () =&gt; ({&#10;  createTransport: () =&gt; ({&#10;    sendMail: jest.fn().mockResolvedValue(true),&#10;  }),&#10;}));&#10;&#10;// Ensure DB schema is ready for any non-mocked model usage&#10;const { sequelize } = require('../src/config/database');&#10;beforeAll(async () =&gt; {&#10;  try {&#10;    await sequelize.sync({ force: true });&#10;  } catch (e) {&#10;    console.error('DB sync error:', e.message);&#10;  }&#10;});&#10;&#10;afterAll(async () =&gt; {&#10;  try {&#10;    await sequelize.close();&#10;  } catch (e) {&#10;    // ignore&#10;  }&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>